/*
 1. Ndertoni funksionin qe gjen mesataren e eksperiences te punonjesve te nje departamenti me department_id qe merret nga perdoruesi.
 */

CREATE OR REPLACE FUNCTION GET_AVERAGE_EXPERIENCE_FOR_DEPARTMENT_BY_ID(
    in_department_id DEPARTMENTS.DEPARTMENT_ID%TYPE
) RETURN NUMBER
    IS
    avg_experience NUMBER := 0;
BEGIN
    SELECT AVG(SYSDATE - HIRE_DATE)
    into avg_experience
    FROM EMPLOYEES
    WHERE DEPARTMENT_ID = in_department_id;

    RETURN ROUND(NVL((avg_experience), 0)/365, 2);
END;

--Call the function

DECLARE
avg_experience NUMBER := 0;
BEGIN
    avg_experience := GET_AVERAGE_EXPERIENCE_FOR_DEPARTMENT_BY_ID(90);
    DBMS_OUTPUT.PUT_LINE('Average experience for department with an ID of 90: ' || avg_experience || ' years');
END;


/*
 2. Ndertoni procedure qe perditeson rrogen e punonjesve ne baze te performances. Rroga e re (salary*perqindje).
    Nese performance 1-> 100, 2-> 150, 3-> 200.
 */

 -- NUK KEMI KOLONE QE RUAN PERFORMANCEN NE DATABAZEN TONE!!!


/*
 3. Ndertoni nje funksion qe llogarit bonusin per punonjesit ne baze te viteve qe ata kane ne kompani.
    (me shume se 5 vite -> 40% e pages ne te kundert 20%).
 */

CREATE OR REPLACE FUNCTION CALCULATE_BONUS(
    in_employee_id EMPLOYEES.EMPLOYEE_ID%TYPE
) RETURN NUMBER
    IS
    bonus NUMBER := 0;
    years_of_experience NUMBER := 0;
    employee_salary NUMBER := 0;
BEGIN

    SELECT ROUND((SYSDATE - HIRE_DATE)/365, 2) as experience, SALARY
    INTO years_of_experience, employee_salary
    FROM EMPLOYEES
    WHERE EMPLOYEE_ID = in_employee_id;

    IF years_of_experience > 5 THEN
        bonus := employee_salary * 0.4;
    ELSE
        bonus := employee_salary * 0.2;
    END IF;

    RETURN bonus;
END;

SELECT SALARY FROM EMPLOYEES WHERE EMPLOYEE_ID = 100;

--Call the function
DECLARE
    bonus NUMBER := 0;
BEGIN
    bonus := CALCULATE_BONUS(100);
    DBMS_OUTPUT.PUT_LINE('Bonusi: ' || bonus);
END;

/*
 4. Ndertoni nje table audit qe mban te dhenat per ndryshimet qe behen ne tabelat e ndryshme.
    (audit_id, table_name, transaction_name, by_user, transaction_date).
    Ndertoni trigger per tabelen customers qe behet run sa here qe ka ndryshime ne table dhe I ruan te dhenat ne audit.
 */

 CREATE TABLE CUSTOMERS_AUDIT (
    audit_id NUMBER(6) GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    table_name VARCHAR2(50),
    transaction_name VARCHAR2(50),
    by_user VARCHAR2(50),
    transaction_date DATE
 );

CREATE OR REPLACE TRIGGER AUDIT_TRIGGER
AFTER INSERT OR UPDATE OR DELETE ON CUSTOMERS
FOR EACH ROW
DECLARE
    v_table_name VARCHAR2(50);
    v_transaction_name VARCHAR2(50);
    v_by_user VARCHAR2(50);
    v_transaction_date DATE;
BEGIN
    v_table_name := 'CUSTOMERS';
    v_transaction_name := CASE
        WHEN INSERTING THEN 'INSERT'
        WHEN UPDATING THEN 'UPDATE'
        WHEN DELETING THEN 'DELETE'
    END;
    v_by_user := USER;
    v_transaction_date := SYSDATE;

    INSERT INTO CUSTOMERS_AUDIT (table_name, transaction_name, by_user, transaction_date)
    VALUES (v_table_name, v_transaction_name, v_by_user, v_transaction_date);
END;

-- Test the trigger
INSERT INTO CUSTOMERS (CUSTOMER_ID, NAME, ADDRESS, WEBSITE, CREDIT_LIMIT)
VALUES (101, 'Test Customer', 'Test Address', 'www.testcustomer.com', 5000);

UPDATE CUSTOMERS SET ADDRESS = 'Updated Address' WHERE CUSTOMER_ID = 101;

DELETE FROM CUSTOMERS WHERE CUSTOMER_ID = 101;

SELECT * FROM CUSTOMERS_AUDIT;

/*
 5. Ndertoni trigger per tabelen customers qe nuk lejon update te krediteve nga data 20 deri ne 30 te cdo muaj.
 */

CREATE OR REPLACE TRIGGER BLOCK_CREDIT_UPDATE
    BEFORE UPDATE OF CREDIT_LIMIT
    ON CUSTOMERS
    FOR EACH ROW
DECLARE
    v_current_date DATE := SYSDATE;
    v_start_date   NUMBER := 20;
    v_end_date     NUMBER := 30;
BEGIN
    IF EXTRACT(DAY FROM v_current_date) BETWEEN v_start_date AND v_end_date THEN
        RAISE_APPLICATION_ERROR(-20001,
                                'Nuk lejohet ndryshimi i limitit te krediteve nga data 20 deri ne 30 te cdo muaji.');
    END IF;
END;

-- Test the trigger
UPDATE CUSTOMERS SET CREDIT_LIMIT = 6000 WHERE CUSTOMER_ID = 1;

/*
 6. Ndertoni trigger per tabelen customers qe nuk lejon update te krediteve ne me shume se 3-fishi nga krediti egzistues.
 */

CREATE OR REPLACE TRIGGER BLOCK_CREDIT_UPDATE_LIMIT
    BEFORE UPDATE OF CREDIT_LIMIT
    ON CUSTOMERS
    FOR EACH ROW
BEGIN
    IF :NEW.CREDIT_LIMIT > 3 * :OLD.CREDIT_LIMIT THEN
        RAISE_APPLICATION_ERROR(-20002,
                                'Vlera e re e limitit '
                                 || TO_CHAR(:NEW.CREDIT_LIMIT)
                                 || ' nuk mund te jete me e madhe se 3-fishi i vleres se vjeter '
                                 || TO_CHAR(:OLD.CREDIT_LIMIT));
    END IF;
END;

-- Test the trigger

SELECT CREDIT_LIMIT FROM CUSTOMERS WHERE CUSTOMER_ID = 1;

UPDATE CUSTOMERS SET CREDIT_LIMIT = 50000 WHERE CUSTOMER_ID = 1;

